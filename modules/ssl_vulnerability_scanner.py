#!/usr/bin/env python3
"""
SSL/TLS Vulnerability Scanner Module
Tests for specific SSL/TLS vulnerabilities including Heartbleed, POODLE, BEAST, 
CRIME, and cipher suite weaknesses.
"""

import os
import sys
import socket
import ssl
import requests
import json
import re
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed

# Fix encoding issues for Windows
if sys.platform.startswith('win'):
    import codecs
    sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
    sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')

# Add parent directory for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from utils.util import clean_domain_input
    from config.settings import USER_AGENT, DEFAULT_TIMEOUT
except ImportError:
    # Fallback implementations
    def clean_domain_input(domain):
        """Clean domain input"""
        if not domain:
            return ""
        domain = domain.strip().lower()
        domain = domain.replace('http://', '').replace('https://', '')
        domain = domain.replace('www.', '')
        if '/' in domain:
            domain = domain.split('/')[0]
        return domain
    
    USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    DEFAULT_TIMEOUT = 10

# Import findings system
try:
    from config.findings_rules import evaluate_findings, display_findings_result
    FINDINGS_AVAILABLE = True
except ImportError:
    print("[W] Findings system not available - running in legacy mode")
    FINDINGS_AVAILABLE = False

def get_ssl_ports():
    """Get common SSL/TLS ports to test"""
    return [443, 8443, 9443, 10443, 11443, 12443, 13443, 14443, 15443]

def test_heartbleed_vulnerability(target, port):
    """Test for Heartbleed vulnerability (CVE-2014-0160)"""
    try:
        # Heartbleed test payload
        heartbeat_payload = b"\x18\x03\x03\x00\x03\x01\x40\x00"
        
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((target, port))
        
        # Wrap socket with SSL
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        
        ssl_sock = context.wrap_socket(sock, server_hostname=target)
        
        # Send heartbeat payload
        ssl_sock.send(heartbeat_payload)
        
        # Try to receive response
        try:
            response = ssl_sock.recv(1024)
            if len(response) > 0:
                return True, "Heartbleed vulnerability detected - server responded to malformed heartbeat"
        except:
            pass
        
        ssl_sock.close()
        return False, "No Heartbleed vulnerability detected"
    
    except Exception as e:
        return False, f"Error testing Heartbleed: {str(e)}"

def test_poodle_vulnerability(target, port):
    """Test for POODLE vulnerability (CVE-2014-3566)"""
    try:
        # Test SSL 3.0 support
        context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
        context.options |= ssl.OP_NO_SSLv2
        context.options |= ssl.OP_NO_TLSv1_3
        
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((target, port))
        
        ssl_sock = context.wrap_socket(sock, server_hostname=target)
        
        # Check if SSL 3.0 is supported
        if ssl_sock.version() == 'SSLv3':
            ssl_sock.close()
            return True, "POODLE vulnerability detected - SSL 3.0 is enabled"
        
        ssl_sock.close()
        return False, "No POODLE vulnerability detected - SSL 3.0 is disabled"
    
    except Exception as e:
        return False, f"Error testing POODLE: {str(e)}"

def test_beast_vulnerability(target, port):
    """Test for BEAST vulnerability (CVE-2011-3389)"""
    try:
        # Test TLS 1.0 support with CBC ciphers
        context = ssl.SSLContext(ssl.PROTOCOL_TLS)
        context.options |= ssl.OP_NO_SSLv2
        context.options |= ssl.OP_NO_SSLv3
        context.options |= ssl.OP_NO_TLSv1_1
        context.options |= ssl.OP_NO_TLSv1_2
        context.options |= ssl.OP_NO_TLSv1_3
        
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((target, port))
        
        ssl_sock = context.wrap_socket(sock, server_hostname=target)
        
        # Check if TLS 1.0 is supported
        if ssl_sock.version() == 'TLSv1':
            ssl_sock.close()
            return True, "BEAST vulnerability detected - TLS 1.0 is enabled"
        
        ssl_sock.close()
        return False, "No BEAST vulnerability detected - TLS 1.0 is disabled"
    
    except Exception as e:
        return False, f"Error testing BEAST: {str(e)}"

def test_weak_ciphers(target, port):
    """Test for weak cipher suites"""
    weak_ciphers = [
        'RC4',
        'DES',
        '3DES',
        'MD5',
        'NULL',
        'EXPORT',
        'LOW',
        'MEDIUM'
    ]
    
    try:
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((target, port))
        
        ssl_sock = context.wrap_socket(sock, server_hostname=target)
        
        # Get cipher information
        cipher = ssl_sock.cipher()
        cipher_name = cipher[0]
        
        # Check for weak ciphers
        weak_ciphers_found = []
        for weak_cipher in weak_ciphers:
            if weak_cipher.lower() in cipher_name.lower():
                weak_ciphers_found.append(weak_cipher)
        
        ssl_sock.close()
        
        if weak_ciphers_found:
            return True, f"Weak ciphers detected: {', '.join(weak_ciphers_found)}"
        
        return False, "No weak ciphers detected"
    
    except Exception as e:
        return False, f"Error testing weak ciphers: {str(e)}"

def test_certificate_issues(target, port):
    """Test for certificate-related issues"""
    issues = []
    
    try:
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((target, port))
        
        ssl_sock = context.wrap_socket(sock, server_hostname=target)
        
        # Get certificate
        cert = ssl_sock.getpeercert()
        
        if not cert:
            issues.append("No certificate presented")
        else:
            # Check certificate expiration
            from datetime import datetime
            not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
            if not_after < datetime.now():
                issues.append("Certificate expired")
            
            # Check certificate validity period
            not_before = datetime.strptime(cert['notBefore'], '%b %d %H:%M:%S %Y %Z')
            if not_before > datetime.now():
                issues.append("Certificate not yet valid")
            
            # Check for self-signed certificate
            if 'subject' in cert and 'issuer' in cert:
                if cert['subject'] == cert['issuer']:
                    issues.append("Self-signed certificate")
        
        ssl_sock.close()
        
        if issues:
            return True, f"Certificate issues detected: {', '.join(issues)}"
        
        return False, "No certificate issues detected"
    
    except Exception as e:
        return False, f"Error testing certificate: {str(e)}"

def test_protocol_support(target, port):
    """Test supported SSL/TLS protocols"""
    protocols = {
        'SSLv2': ssl.PROTOCOL_SSLv2,
        'SSLv3': ssl.PROTOCOL_SSLv3,
        'TLSv1.0': ssl.PROTOCOL_TLSv1,
        'TLSv1.1': ssl.PROTOCOL_TLSv1_1,
        'TLSv1.2': ssl.PROTOCOL_TLSv1_2,
        'TLSv1.3': ssl.PROTOCOL_TLSv1_3
    }
    
    supported_protocols = []
    vulnerabilities = []
    
    for protocol_name, protocol_constant in protocols.items():
        try:
            context = ssl.SSLContext(protocol_constant)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((target, port))
            
            ssl_sock = context.wrap_socket(sock, server_hostname=target)
            supported_protocols.append(protocol_name)
            ssl_sock.close()
            
        except Exception:
            continue
    
    # Check for vulnerable protocols
    vulnerable_protocols = ['SSLv2', 'SSLv3', 'TLSv1.0', 'TLSv1.1']
    for protocol in vulnerable_protocols:
        if protocol in supported_protocols:
            vulnerabilities.append(f"{protocol} is enabled")
    
    if vulnerabilities:
        return True, f"Vulnerable protocols detected: {', '.join(vulnerabilities)}"
    
    return False, f"Supported protocols: {', '.join(supported_protocols)}"

def test_ssl_configuration(target, port):
    """Test overall SSL configuration"""
    issues = []
    
    try:
        # Test with default context
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((target, port))
        
        ssl_sock = context.wrap_socket(sock, server_hostname=target)
        
        # Get SSL information
        cipher = ssl_sock.cipher()
        cert = ssl_sock.getpeercert()
        
        # Check for security issues
        if not cert:
            issues.append("No certificate presented")
        
        # Check cipher strength
        cipher_name = cipher[0]
        if 'RC4' in cipher_name or 'DES' in cipher_name or '3DES' in cipher_name:
            issues.append("Weak cipher suite in use")
        
        # Check key exchange
        if 'RSA' in cipher_name and '1024' in cipher_name:
            issues.append("Weak RSA key (1024-bit)")
        
        ssl_sock.close()
        
        if issues:
            return True, f"SSL configuration issues: {', '.join(issues)}"
        
        return False, "SSL configuration appears secure"
    
    except Exception as e:
        return False, f"Error testing SSL configuration: {str(e)}"

def scan_ssl_vulnerabilities(target, port):
    """Scan a specific port for SSL vulnerabilities"""
    vulnerabilities = []
    
    # Test various SSL vulnerabilities
    tests = [
        ("Heartbleed", test_heartbleed_vulnerability),
        ("POODLE", test_poodle_vulnerability),
        ("BEAST", test_beast_vulnerability),
        ("Weak Ciphers", test_weak_ciphers),
        ("Certificate Issues", test_certificate_issues),
        ("Protocol Support", test_protocol_support),
        ("SSL Configuration", test_ssl_configuration)
    ]
    
    for test_name, test_func in tests:
        try:
            is_vulnerable, message = test_func(target, port)
            
            if is_vulnerable:
                vulnerabilities.append({
                    "port": port,
                    "vulnerability": test_name,
                    "description": message,
                    "severity": "high" if test_name in ["Heartbleed", "POODLE", "BEAST"] else "medium",
                    "vulnerable": True
                })
        
        except Exception as e:
            print(f"[E] Error testing {test_name} on {target}:{port} - {str(e)}")
    
    return vulnerabilities

def perform_ssl_vulnerability_scan(target):
    """Perform comprehensive SSL vulnerability scan"""
    print(f"[I] Starting SSL vulnerability scan for {target}")
    
    # Get SSL ports to test
    ssl_ports = get_ssl_ports()
    
    # Scan each port for SSL vulnerabilities
    all_vulnerabilities = []
    
    with ThreadPoolExecutor(max_workers=5) as executor:
        future_to_port = {executor.submit(scan_ssl_vulnerabilities, target, port): port for port in ssl_ports}
        
        for future in as_completed(future_to_port):
            port = future_to_port[future]
            try:
                vulnerabilities = future.result()
                all_vulnerabilities.extend(vulnerabilities)
            except Exception as e:
                print(f"[E] Error scanning {target}:{port} - {str(e)}")
    
    return {
        "target": target,
        "ports_tested": len(ssl_ports),
        "vulnerabilities_found": len(all_vulnerabilities),
        "vulnerabilities": all_vulnerabilities,
        "scan_time": datetime.now().isoformat()
    }

def assess_ssl_vulnerability_risk(results):
    """Assess security risk level of SSL vulnerability findings"""
    findings = []
    severity = "I"
    
    vulnerabilities = results.get("vulnerabilities", [])
    
    if not vulnerabilities:
        return findings, severity
    
    # Count vulnerabilities by severity
    critical_vulns = []
    high_vulns = []
    medium_vulns = []
    
    for vuln in vulnerabilities:
        vuln_severity = vuln.get("severity", "medium")
        if vuln_severity == "critical":
            critical_vulns.append(vuln)
        elif vuln_severity == "high":
            high_vulns.append(vuln)
        else:
            medium_vulns.append(vuln)
    
    # Critical findings - Heartbleed, POODLE, BEAST
    if critical_vulns:
        severity = "C"
        findings.append(f"Critical SSL vulnerabilities: {len(critical_vulns)} critical issues detected")
        
        # List critical vulnerabilities
        for vuln in critical_vulns[:3]:  # Show first 3
            vuln_type = vuln.get("vulnerability", "Unknown")
            description = vuln.get("description", "No description")
            findings.append(f"Critical: {vuln_type} - {description}")
    
    # High findings
    if high_vulns:
        if severity == "I":
            severity = "H"
        findings.append(f"High-risk SSL vulnerabilities: {len(high_vulns)} high-severity issues detected")
    
    # Medium findings
    if medium_vulns:
        if severity == "I":
            severity = "M"
        findings.append(f"Medium-risk SSL vulnerabilities: {len(medium_vulns)} medium-severity issues detected")
    
    # Overall assessment
    total_vulns = len(vulnerabilities)
    if total_vulns > 5:
        if severity not in ["C", "H"]:
            severity = "H"
        findings.append(f"Multiple SSL vulnerabilities: {total_vulns} security issues detected")
    
    return findings, severity

def main(target):
    """Main execution with enhanced findings evaluation"""
    print(f"[I] SSL Vulnerability Scanner - {target}")
    print("=" * 50)
    
    start_time = datetime.now()
    
    try:
        if not target:
            print("[E] FAILED: Empty target provided")
            return {
                "status": "FAILED",
                "error": "Empty target",
                "execution_time": (datetime.now() - start_time).total_seconds()
            }
        
        # Clean target input
        target = clean_domain_input(target)
        if not target:
            print("[E] FAILED: Invalid target format")
            return {
                "status": "FAILED",
                "error": "Invalid target format",
                "execution_time": (datetime.now() - start_time).total_seconds()
            }
        
        print(f"[I] Target: {target}")
        print()
        
        # Perform SSL vulnerability scan
        results = perform_ssl_vulnerability_scan(target)
        execution_time = (datetime.now() - start_time).total_seconds()
        
        # Prepare scan data for findings evaluation
        vulnerabilities = results.get("vulnerabilities", [])
        ports_tested = results.get("ports_tested", 0)
        
        scan_data = {
            "target": target,
            "ports_tested": ports_tested,
            "vulnerabilities_found": len(vulnerabilities),
            "critical_vulnerabilities": len([v for v in vulnerabilities if v.get("severity") == "critical"]),
            "high_vulnerabilities": len([v for v in vulnerabilities if v.get("severity") == "high"]),
            "medium_vulnerabilities": len([v for v in vulnerabilities if v.get("severity") == "medium"]),
            "vulnerabilities": vulnerabilities,
            "status": "SUCCESS" if vulnerabilities else "NO_DATA",
            "scan_completed": True
        }
        
        if vulnerabilities:
            # Assess security risk
            security_findings, severity = assess_ssl_vulnerability_risk(results)
            
            print(f"[{severity}] SSL VULNERABILITIES FOUND: {len(vulnerabilities)} security issues detected across {ports_tested} ports")
            
            # Display vulnerability summary
            print(f"[{severity}] Vulnerability Summary:")
            critical_count = len([v for v in vulnerabilities if v.get("severity") == "critical"])
            high_count = len([v for v in vulnerabilities if v.get("severity") == "high"])
            medium_count = len([v for v in vulnerabilities if v.get("severity") == "medium"])
            
            if critical_count > 0:
                print(f"  [C] Critical: {critical_count}")
            if high_count > 0:
                print(f"  [H] High: {high_count}")
            if medium_count > 0:
                print(f"  [M] Medium: {medium_count}")
            print()
            
            # Display vulnerable ports
            if vulnerabilities:
                print(f"[I] VULNERABLE PORTS ({len(vulnerabilities)}):")
                for vuln in vulnerabilities[:10]:  # Show first 10
                    port = vuln.get("port", "Unknown")
                    vuln_type = vuln.get("vulnerability", "Unknown")
                    description = vuln.get("description", "No description")
                    vuln_severity = vuln.get("severity", "medium")
                    
                    print(f"  [{vuln_severity.upper()}] {port}/tcp - {vuln_type}: {description}")
                
                if len(vulnerabilities) > 10:
                    print(f"  [I] ... and {len(vulnerabilities) - 10} more vulnerabilities")
                print()
            
            # Display security findings
            if security_findings:
                print(f"[{severity}] Security Risk Analysis:")
                for finding in security_findings:
                    print(f"  [{severity}] {finding}")
                print()
        else:
            print("[I] NO DATA: No SSL vulnerabilities found")
            security_findings = []
            severity = "I"
        
        print()
        
        # Enhanced findings evaluation
        if FINDINGS_AVAILABLE:
            findings_result = evaluate_findings("ssl_vulnerability_scanner.py", scan_data)
            display_findings_result(scan_data, findings_result)
        else:
            # Fallback to basic assessment
            if vulnerabilities:
                findings = security_findings if security_findings else [f"Found {len(vulnerabilities)} SSL vulnerabilities"]
            else:
                findings = ["No SSL vulnerabilities detected"]
            
            findings_result = {
                "success": len(vulnerabilities) > 0,
                "severity": severity,
                "findings": findings,
                "has_findings": len(vulnerabilities) > 0,
                "category": "SSL Vulnerability Assessment"
            }
        
        print(f"[I] Execution time: {execution_time:.2f}s")
        print()
        
        # Return standardized format
        return {
            "status": "SUCCESS" if findings_result["success"] else "FAILED",
            "data": scan_data,
            "findings": findings_result,
            "execution_time": execution_time,
            "target": target,
            # Keep legacy fields for backward compatibility
            "vulnerabilities": vulnerabilities,
            "ports_tested": ports_tested,
            "severity": findings_result["severity"]
        }
        
    except KeyboardInterrupt:
        print("[I] INTERRUPTED: SSL vulnerability scan stopped by user")
        return {
            "status": "INTERRUPTED",
            "execution_time": (datetime.now() - start_time).total_seconds()
        }
        
    except Exception as e:
        execution_time = (datetime.now() - start_time).total_seconds()
        print(f"[E] FAILED: SSL vulnerability scan error - {str(e)}")
        return {
            "status": "FAILED",
            "error": str(e),
            "execution_time": execution_time
        }

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python ssl_vulnerability_scanner.py <target>")
        sys.exit(1)
    
    target = sys.argv[1]
    result = main(target)
    print(json.dumps(result, indent=2)) 