#!/usr/bin/env python3
"""
XSS Vulnerability Scanner Module
Tests web applications for reflected, stored, and DOM-based Cross-Site Scripting 
vulnerabilities using sophisticated payload encoding and bypass techniques.
"""

import os
import sys
import requests
import json
import re
import time
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, quote

# Fix encoding issues for Windows
if sys.platform.startswith('win'):
    import codecs
    sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
    sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')

# Add parent directory for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from utils.util import clean_domain_input
    from config.settings import USER_AGENT, DEFAULT_TIMEOUT
except ImportError:
    # Fallback implementations
    def clean_domain_input(domain):
        """Clean domain input"""
        if not domain:
            return ""
        domain = domain.strip().lower()
        domain = domain.replace('http://', '').replace('https://', '')
        domain = domain.replace('www.', '')
        if '/' in domain:
            domain = domain.split('/')[0]
        return domain
    
    USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    DEFAULT_TIMEOUT = 10

# Import findings system
try:
    from config.findings_rules import evaluate_findings, display_findings_result
    FINDINGS_AVAILABLE = True
except ImportError:
    print("[W] Findings system not available - running in legacy mode")
    FINDINGS_AVAILABLE = False

def get_xss_payloads():
    """Get comprehensive XSS payloads for testing"""
    return {
        "reflected": [
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>",
            "<video><source onerror=alert('XSS')>",
            "<audio src=x onerror=alert('XSS')>",
            "<details open ontoggle=alert('XSS')>",
            "<marquee onstart=alert('XSS')>",
            "<div onmouseover=alert('XSS')>Hover me</div>",
            "<a href=javascript:alert('XSS')>Click me</a>",
            "<form onsubmit=alert('XSS')><input type=submit></form>",
            "<button onclick=alert('XSS')>Click me</button>",
            "<label onfocus=alert('XSS') tabindex=1>Click me</label>",
            "<meter onmouseover=alert('XSS')>Hover me</meter>"
        ],
        "encoded": [
            "&#60;script&#62;alert('XSS')&#60;/script&#62;",
            "&#x3c;script&#x3e;alert('XSS')&#x3c;/script&#x3e;",
            "%3Cscript%3Ealert('XSS')%3C/script%3E",
            "\\u003Cscript\\u003Ealert('XSS')\\u003C/script\\u003E",
            "\\x3Cscript\\x3Ealert('XSS')\\x3C/script\\x3E",
            "\\074script\\076alert('XSS')\\074/script\\076",
            "\\x3cscript\\x3ealert('XSS')\\x3c/script\\x3e",
            "\\u003cscript\\u003ealert('XSS')\\u003c/script\\u003e"
        ],
        "bypass": [
            "<ScRiPt>alert('XSS')</ScRiPt>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>",
            "<script>alert('XSS')</script>"
        ],
        "dom": [
            "javascript:alert('XSS')",
            "javascript:alert('XSS')",
            "javascript:alert('XSS')",
            "javascript:alert('XSS')",
            "javascript:alert('XSS')",
            "javascript:alert('XSS')",
            "javascript:alert('XSS')",
            "javascript:alert('XSS')",
            "javascript:alert('XSS')",
            "javascript:alert('XSS')"
        ]
    }

def get_common_web_endpoints():
    """Get common web endpoints to test for XSS"""
    return [
        "/",
        "/index.php",
        "/index.html",
        "/search.php",
        "/search.html",
        "/contact.php",
        "/contact.html",
        "/feedback.php",
        "/feedback.html",
        "/comment.php",
        "/comment.html",
        "/review.php",
        "/review.html",
        "/guestbook.php",
        "/guestbook.html",
        "/forum/",
        "/forum/index.php",
        "/blog/",
        "/blog/index.php",
        "/news/",
        "/news/index.php",
        "/article.php",
        "/article.html",
        "/product.php",
        "/product.html",
        "/user/",
        "/user/profile.php",
        "/profile.php",
        "/profile.html",
        "/account.php",
        "/account.html",
        "/admin/",
        "/admin/index.php",
        "/panel/",
        "/panel/index.php"
    ]

def detect_xss_in_response(response_text, payload):
    """Detect XSS payload in response"""
    # Check if payload is reflected in response
    if payload in response_text:
        return True, "Payload Reflected"
    
    # Check for encoded payloads
    encoded_payloads = [
        payload.replace("<", "&lt;").replace(">", "&gt;"),
        payload.replace("<", "&#60;").replace(">", "&#62;"),
        payload.replace("<", "&#x3c;").replace(">", "&#x3e;"),
        payload.replace("<", "%3C").replace(">", "%3E"),
        payload.replace("<", "\\u003c").replace(">", "\\u003e"),
        payload.replace("<", "\\x3c").replace(">", "\\x3e")
    ]
    
    for encoded in encoded_payloads:
        if encoded in response_text:
            return True, "Encoded Payload Reflected"
    
    # Check for script tags in response
    script_patterns = [
        r"<script[^>]*>",
        r"javascript:",
        r"on\w+\s*=",
        r"<iframe[^>]*>",
        r"<object[^>]*>",
        r"<embed[^>]*>",
        r"<applet[^>]*>"
    ]
    
    for pattern in script_patterns:
        if re.search(pattern, response_text, re.IGNORECASE):
            return True, "Script-like Content Detected"
    
    return False, "No XSS Detected"

def test_parameter_xss(base_url, param_name, param_value, payload):
    """Test a specific parameter for XSS"""
    try:
        # Create test URL with payload
        test_params = {param_name: payload}
        test_url = f"{base_url}?{urlencode(test_params)}"
        
        # Send request
        headers = {
            'User-Agent': USER_AGENT,
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
        }
        
        response = requests.get(test_url, headers=headers, timeout=DEFAULT_TIMEOUT, verify=False)
        
        # Check for XSS
        is_vulnerable, reason = detect_xss_in_response(response.text, payload)
        
        if is_vulnerable:
            return {
                "url": test_url,
                "parameter": param_name,
                "payload": payload,
                "response_code": response.status_code,
                "response_length": len(response.text),
                "reason": reason,
                "vulnerable": True
            }
        
        return None
    
    except Exception as e:
        print(f"[E] Error testing parameter {param_name} with payload {payload}: {str(e)}")
        return None

def test_form_xss(base_url, form_data, payload):
    """Test form submission for XSS"""
    try:
        # Create test form data with payload
        test_form_data = {}
        for field_name, field_value in form_data.items():
            if isinstance(field_value, str) and len(field_value) < 100:  # Only test short text fields
                test_form_data[field_name] = payload
            else:
                test_form_data[field_name] = field_value
        
        # Send POST request
        headers = {
            'User-Agent': USER_AGENT,
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Connection': 'keep-alive',
        }
        
        response = requests.post(base_url, data=test_form_data, headers=headers, timeout=DEFAULT_TIMEOUT, verify=False)
        
        # Check for XSS
        is_vulnerable, reason = detect_xss_in_response(response.text, payload)
        
        if is_vulnerable:
            return {
                "url": base_url,
                "method": "POST",
                "form_data": test_form_data,
                "payload": payload,
                "response_code": response.status_code,
                "response_length": len(response.text),
                "reason": reason,
                "vulnerable": True
            }
        
        return None
    
    except Exception as e:
        print(f"[E] Error testing form XSS: {str(e)}")
        return None

def discover_web_endpoints(target):
    """Discover web endpoints on the target"""
    endpoints = []
    
    # Try common protocols
    protocols = ["https", "http"]
    
    for protocol in protocols:
        base_url = f"{protocol}://{target}"
        
        # Test common endpoints
        common_endpoints = get_common_web_endpoints()
        
        for endpoint in common_endpoints:
            try:
                url = urljoin(base_url, endpoint)
                headers = {
                    'User-Agent': USER_AGENT,
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                }
                
                response = requests.get(url, headers=headers, timeout=DEFAULT_TIMEOUT, verify=False)
                
                if response.status_code == 200:
                    endpoints.append({
                        "url": url,
                        "status_code": response.status_code,
                        "content_type": response.headers.get('content-type', ''),
                        "content_length": len(response.text)
                    })
            
            except Exception as e:
                continue
    
    return endpoints

def extract_parameters_from_url(url):
    """Extract parameters from URL for testing"""
    parsed = urlparse(url)
    params = parse_qs(parsed.query)
    
    # Convert list values to single values for testing
    test_params = {}
    for key, values in params.items():
        if values:
            test_params[key] = values[0]
    
    return test_params

def scan_endpoint_for_xss(endpoint_info):
    """Scan a specific endpoint for XSS vulnerabilities"""
    vulnerabilities = []
    url = endpoint_info["url"]
    
    # Extract parameters from URL
    url_params = extract_parameters_from_url(url)
    
    # Get XSS payloads
    payloads = get_xss_payloads()
    
    # Test URL parameters
    for param_name, param_value in url_params.items():
        for payload_type, payload_list in payloads.items():
            for payload in payload_list[:3]:  # Limit to first 3 payloads per type
                result = test_parameter_xss(url, param_name, param_value, payload)
                if result:
                    result["payload_type"] = payload_type
                    vulnerabilities.append(result)
    
    # Test form XSS if it's a form page
    if any(keyword in url.lower() for keyword in ["contact", "feedback", "comment", "review", "guestbook", "forum", "blog"]):
        # Common form field names
        form_fields = {
            "name": "test",
            "email": "test@example.com",
            "message": "test",
            "comment": "test",
            "review": "test",
            "feedback": "test",
            "content": "test",
            "description": "test",
            "title": "test",
            "subject": "test"
        }
        
        for payload_type, payload_list in payloads.items():
            for payload in payload_list[:2]:  # Limit payloads for forms
                result = test_form_xss(url, form_fields, payload)
                if result:
                    result["payload_type"] = payload_type
                    vulnerabilities.append(result)
    
    return vulnerabilities

def perform_xss_scan(target):
    """Perform comprehensive XSS vulnerability scan"""
    print(f"[I] Starting XSS vulnerability scan for {target}")
    
    # Discover web endpoints
    endpoints = discover_web_endpoints(target)
    
    if not endpoints:
        print(f"[W] No web endpoints discovered for {target}")
        return {
            "target": target,
            "endpoints_discovered": 0,
            "vulnerabilities_found": 0,
            "scan_time": datetime.now().isoformat()
        }
    
    print(f"[I] Discovered {len(endpoints)} web endpoints")
    
    # Scan each endpoint for XSS
    all_vulnerabilities = []
    
    with ThreadPoolExecutor(max_workers=5) as executor:
        future_to_endpoint = {executor.submit(scan_endpoint_for_xss, endpoint): endpoint for endpoint in endpoints}
        
        for future in as_completed(future_to_endpoint):
            endpoint = future_to_endpoint[future]
            try:
                vulnerabilities = future.result()
                all_vulnerabilities.extend(vulnerabilities)
            except Exception as e:
                print(f"[E] Error scanning endpoint {endpoint['url']}: {str(e)}")
    
    return {
        "target": target,
        "endpoints_discovered": len(endpoints),
        "endpoints_scanned": len(endpoints),
        "vulnerabilities_found": len(all_vulnerabilities),
        "vulnerabilities": all_vulnerabilities,
        "scan_time": datetime.now().isoformat()
    }

def assess_xss_vulnerability_risk(results):
    """Assess security risk level of XSS findings"""
    findings = []
    severity = "I"
    
    vulnerabilities = results.get("vulnerabilities", [])
    endpoints_discovered = results.get("endpoints_discovered", 0)
    
    if not vulnerabilities:
        return findings, severity
    
    # Count vulnerabilities by type
    reflected = len([v for v in vulnerabilities if v.get("payload_type") == "reflected"])
    encoded = len([v for v in vulnerabilities if v.get("payload_type") == "encoded"])
    bypass = len([v for v in vulnerabilities if v.get("payload_type") == "bypass"])
    dom = len([v for v in vulnerabilities if v.get("payload_type") == "dom"])
    
    # High findings - Reflected XSS
    if reflected > 0:
        severity = "H"
        findings.append(f"High-risk XSS vulnerabilities: {reflected} reflected XSS injection points detected")
        
        # List high vulnerabilities
        reflected_vulns = [v for v in vulnerabilities if v.get("payload_type") == "reflected"]
        for vuln in reflected_vulns[:3]:  # Show first 3
            url = vuln.get("url", "Unknown")
            param = vuln.get("parameter", "Unknown")
            findings.append(f"High: Reflected XSS in {url} parameter: {param}")
    
    # Medium findings - Encoded XSS
    if encoded > 0:
        if severity == "I":
            severity = "M"
        findings.append(f"Medium-risk XSS vulnerabilities: {encoded} encoded XSS injection points detected")
    
    # Medium findings - Bypass XSS
    if bypass > 0:
        if severity == "I":
            severity = "M"
        findings.append(f"Medium-risk XSS vulnerabilities: {bypass} bypass XSS injection points detected")
    
    # High findings - DOM XSS
    if dom > 0:
        if severity == "I":
            severity = "H"
        findings.append(f"High-risk XSS vulnerabilities: {dom} DOM-based XSS injection points detected")
    
    # Overall assessment
    total_vulns = len(vulnerabilities)
    if total_vulns > 5:
        if severity not in ["H", "C"]:
            severity = "H"
        findings.append(f"Multiple XSS vulnerabilities: {total_vulns} injection points across {endpoints_discovered} endpoints")
    
    return findings, severity

def main(target):
    """Main execution with enhanced findings evaluation"""
    print(f"[I] XSS Vulnerability Scanner - {target}")
    print("=" * 50)
    
    start_time = datetime.now()
    
    try:
        if not target:
            print("[E] FAILED: Empty target provided")
            return {
                "status": "FAILED",
                "error": "Empty target",
                "execution_time": (datetime.now() - start_time).total_seconds()
            }
        
        # Clean target input
        target = clean_domain_input(target)
        if not target:
            print("[E] FAILED: Invalid target format")
            return {
                "status": "FAILED",
                "error": "Invalid target format",
                "execution_time": (datetime.now() - start_time).total_seconds()
            }
        
        print(f"[I] Target: {target}")
        print()
        
        # Perform XSS vulnerability scan
        results = perform_xss_scan(target)
        execution_time = (datetime.now() - start_time).total_seconds()
        
        # Prepare scan data for findings evaluation
        vulnerabilities = results.get("vulnerabilities", [])
        endpoints_discovered = results.get("endpoints_discovered", 0)
        
        scan_data = {
            "target": target,
            "endpoints_discovered": endpoints_discovered,
            "vulnerabilities_found": len(vulnerabilities),
            "reflected_vulnerabilities": len([v for v in vulnerabilities if v.get("payload_type") == "reflected"]),
            "encoded_vulnerabilities": len([v for v in vulnerabilities if v.get("payload_type") == "encoded"]),
            "bypass_vulnerabilities": len([v for v in vulnerabilities if v.get("payload_type") == "bypass"]),
            "dom_vulnerabilities": len([v for v in vulnerabilities if v.get("payload_type") == "dom"]),
            "vulnerabilities": vulnerabilities,
            "status": "SUCCESS" if vulnerabilities else "NO_DATA",
            "scan_completed": True
        }
        
        if vulnerabilities:
            # Assess security risk
            security_findings, severity = assess_xss_vulnerability_risk(results)
            
            print(f"[{severity}] XSS VULNERABILITIES FOUND: {len(vulnerabilities)} injection points detected across {endpoints_discovered} endpoints")
            
            # Display vulnerability summary
            print(f"[{severity}] Vulnerability Summary:")
            reflected_count = len([v for v in vulnerabilities if v.get("payload_type") == "reflected"])
            encoded_count = len([v for v in vulnerabilities if v.get("payload_type") == "encoded"])
            bypass_count = len([v for v in vulnerabilities if v.get("payload_type") == "bypass"])
            dom_count = len([v for v in vulnerabilities if v.get("payload_type") == "dom"])
            
            if reflected_count > 0:
                print(f"  [H] Reflected: {reflected_count}")
            if encoded_count > 0:
                print(f"  [M] Encoded: {encoded_count}")
            if bypass_count > 0:
                print(f"  [M] Bypass: {bypass_count}")
            if dom_count > 0:
                print(f"  [H] DOM-based: {dom_count}")
            print()
            
            # Display vulnerable endpoints
            if vulnerabilities:
                print(f"[I] VULNERABLE ENDPOINTS ({len(vulnerabilities)}):")
                for vuln in vulnerabilities[:10]:  # Show first 10
                    url = vuln.get("url", "Unknown")
                    param = vuln.get("parameter", "Unknown")
                    payload_type = vuln.get("payload_type", "Unknown")
                    reason = vuln.get("reason", "Unknown")
                    
                    print(f"  [{severity}] {url} - {param} ({payload_type}) - {reason}")
                
                if len(vulnerabilities) > 10:
                    print(f"  [I] ... and {len(vulnerabilities) - 10} more vulnerabilities")
                print()
            
            # Display security findings
            if security_findings:
                print(f"[{severity}] Security Risk Analysis:")
                for finding in security_findings:
                    print(f"  [{severity}] {finding}")
                print()
        else:
            print("[I] NO DATA: No XSS vulnerabilities found")
            security_findings = []
            severity = "I"
        
        print()
        
        # Enhanced findings evaluation
        if FINDINGS_AVAILABLE:
            findings_result = evaluate_findings("xss_vulnerability_scanner.py", scan_data)
            display_findings_result(scan_data, findings_result)
        else:
            # Fallback to basic assessment
            if vulnerabilities:
                findings = security_findings if security_findings else [f"Found {len(vulnerabilities)} XSS vulnerabilities"]
            else:
                findings = ["No XSS vulnerabilities detected"]
            
            findings_result = {
                "success": len(vulnerabilities) > 0,
                "severity": severity,
                "findings": findings,
                "has_findings": len(vulnerabilities) > 0,
                "category": "XSS Vulnerability Assessment"
            }
        
        print(f"[I] Execution time: {execution_time:.2f}s")
        print()
        
        # Return standardized format
        return {
            "status": "SUCCESS" if findings_result["success"] else "FAILED",
            "data": scan_data,
            "findings": findings_result,
            "execution_time": execution_time,
            "target": target,
            # Keep legacy fields for backward compatibility
            "vulnerabilities": vulnerabilities,
            "endpoints_discovered": endpoints_discovered,
            "severity": findings_result["severity"]
        }
        
    except KeyboardInterrupt:
        print("[I] INTERRUPTED: XSS vulnerability scan stopped by user")
        return {
            "status": "INTERRUPTED",
            "execution_time": (datetime.now() - start_time).total_seconds()
        }
        
    except Exception as e:
        execution_time = (datetime.now() - start_time).total_seconds()
        print(f"[E] FAILED: XSS vulnerability scan error - {str(e)}")
        return {
            "status": "FAILED",
            "error": str(e),
            "execution_time": execution_time
        }

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python xss_vulnerability_scanner.py <target>")
        sys.exit(1)
    
    target = sys.argv[1]
    result = main(target)
    print(json.dumps(result, indent=2)) 